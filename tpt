#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
TPT - La Herramienta de Paquetes de Tovicito
Versión 2.1
Una refactorización completa del script original de TPT para robustez, mantenibilidad y rendimiento.
Toda la lógica está contenida en este único script, organizada en clases.
"""

import sys
import os
import subprocess
import time
import argparse
import requests
import hashlib
import json
import re
from datetime import datetime
from threading import Thread
from queue import Queue
import traceback
from pathlib import Path

# --- GLOBAL: COMPROBACIÓN DE GTK ---
try:
    import gi
    gi.require_version('Gtk', '3.0')
    from gi.repository import Gtk, GLib, Gdk, Gio
    from gi.repository import GdkPixbuf
    HAS_GTK = True
except ImportError:
    HAS_GTK = False

__version__ = "2.1.0"

# =============================================================================
# SECCIÓN 1: INFRAESTRUCTURA DEL NÚCLEO
# =============================================================================

class ErrorTPT(Exception):
    """Excepción base para errores de la aplicación TPT."""
    pass

class ErrorCriticoTPT(ErrorTPT):
    """Para errores que impiden que la aplicación continúe."""
    pass

class Configuracion:
    """Gestiona toda la configuración, rutas y constantes para TPT."""
    def __init__(self):
        self.ARCHIVO_MANIFIESTO_REPO = "packages.json"
        self.RAMA_POR_DEFECTO = "regular"
        self.DIR_EJECUTABLES_ROOT = Path("/usr/local/bin")
        self.DIR_APLICACIONES_ROOT = Path("/usr/share/applications")
        self.DIR_OPT_ROOT = Path("/opt")

        if os.geteuid() == 0:
            self.DIR_ESTADO = Path("/var/lib/tpt")
            self.DIR_CACHE = Path("/var/cache/tpt")
            self.DIR_LOGS = Path("/var/log/tpt")
            self.DIR_CONFIG = Path("/etc/tpt")
        else:
            self.DIR_ESTADO = Path(os.environ.get("XDG_STATE_HOME", Path.home() / ".local/state")) / "tpt"
            self.DIR_CACHE = Path(os.environ.get("XDG_CACHE_HOME", Path.home() / ".cache")) / "tpt"
            self.DIR_LOGS = self.DIR_ESTADO
            self.DIR_CONFIG = Path(os.environ.get("XDG_CONFIG_HOME", Path.home() / ".config")) / "tpt"

        self.BD_PAQUETES_INSTALADOS = self.DIR_ESTADO / "installed.json"
        self.DIR_CACHE_REPOS = self.DIR_CACHE / "repos"
        self.ICON_CACHE_DIR = self.DIR_CACHE / "icons"
        self.ARCHIVO_LOG = self.DIR_LOGS / "tpt.log"
        if Path("tpt-repos.list").exists():
            self.ARCHIVO_REPOS = Path("tpt-repos.list")
        else:
            self.ARCHIVO_REPOS = self.DIR_CONFIG / "tpt-repos.list"
        self.ARCHIVO_RAMA = self.DIR_CONFIG / "branch.txt"

        self.REPOS_POR_DEFECTO = [
            "https://raw.githubusercontent.com/tovicito/NemasOS/regular/",
            "https://raw.githubusercontent.com/sindresorhus/awesome-cli-apps/main/cli-apps/",
            "https://raw.githubusercontent.com/soimort/you-get/master/src/",
            "https://raw.githubusercontent.com/Pylogmon/py_cli_tools/main/",
            "https://raw.githubusercontent.com/sharkdp/fd/master/contrib/completion/",
            "https://raw.githubusercontent.com/dylanaraps/neofetch/master/",
            "https://raw.githubusercontent.com/jarun/nnn/master/plugins/",
            "https://raw.githubusercontent.com/NemasOS-Community/Nemas-Packages/main/"
        ]

    def asegurar_directorios(self):
        """Crea todos los directorios necesarios si no existen."""
        for d in [self.DIR_ESTADO, self.DIR_CACHE, self.DIR_LOGS, self.DIR_CONFIG, self.DIR_CACHE_REPOS, self.ICON_CACHE_DIR]:
            try:
                d.mkdir(parents=True, exist_ok=True)
            except OSError as e:
                raise ErrorCriticoTPT(f"Error al crear el directorio {d}: {e}. Asegúrate de tener permisos.")

class RegistradorTPT:
    def __init__(self, config, cola=None):
        self.config = config
        self.archivo_log = config.ARCHIVO_LOG
        self.niveles_log = {"DEBUG": 0, "INFO": 1, "WARNING": 2, "ERROR": 3, "CRITICAL": 4}
        self.nivel_log_actual = self.niveles_log["INFO"]
        self.cola = cola

    def _log(self, mensaje, nombre_nivel, exc_info=False):
        if self.niveles_log[nombre_nivel] < self.nivel_log_actual: return
        marca_tiempo = datetime.now().strftime("%Y-%m-%d %H:%M:%S.%f")[:-3]
        entrada_log = f"[{marca_tiempo}] [{nombre_nivel}] {mensaje}"
        if exc_info: entrada_log += "\n" + traceback.format_exc()
        try:
            with open(self.archivo_log, 'a', encoding='utf-8') as f: f.write(entrada_log + "\n")
        except OSError as e: print(f"CRÍTICO: No se pudo escribir en el archivo de registro {self.archivo_log}: {e}", file=sys.stderr)
        if self.cola: self.cola.put(entrada_log)
        if not self.cola or self.niveles_log[nombre_nivel] >= self.niveles_log["ERROR"]:
            print(entrada_log, file=sys.stderr if self.niveles_log[nombre_nivel] >= self.niveles_log["ERROR"] else sys.stdout)

    def info(self, mensaje): self._log(mensaje, "INFO")
    def warning(self, mensaje): self._log(mensaje, "WARNING")
    def error(self, mensaje, exc_info=False): self._log(mensaje, "ERROR", exc_info)
    def critical(self, mensaje, exc_info=True): self._log(mensaje, "CRITICAL", exc_info)
    def debug(self, mensaje): self._log(mensaje, "DEBUG")

# =============================================================================
# SECCIÓN 2: GESTIÓN DE PAQUETES DEL NÚCLEO
# =============================================================================

class GestorPaquetes:
    def __init__(self, config, registrador):
        self.config = config
        self.registrador = registrador
        self.callback_progreso = None
        self._sesion = requests.Session()
        self._sesion.headers.update({"User-Agent": f"GestorPaquetesTPT/{__version__}"})

    def _obtener_urls_repos(self):
        if not self.config.ARCHIVO_REPOS.exists():
            self.registrador.info("Archivo de repositorios no encontrado. Creando con valores por defecto.")
            self.config.ARCHIVO_REPOS.parent.mkdir(parents=True, exist_ok=True)
            with open(self.config.ARCHIVO_REPOS, 'w') as f: f.write("\n".join(self.config.REPOS_POR_DEFECTO) + "\n")
            return self.config.REPOS_POR_DEFECTO
        with open(self.config.ARCHIVO_REPOS, 'r') as f: return [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]

    def _obtener_manifiesto(self, url_repo):
        url_manifiesto = url_repo.rstrip('/') + "/" + self.config.ARCHIVO_MANIFIESTO_REPO
        ruta_cache = self.config.DIR_CACHE_REPOS / hashlib.sha256(url_manifiesto.encode()).hexdigest()
        try:
            self.registrador.debug(f"Obteniendo manifiesto desde {url_manifiesto}")
            respuesta = self._sesion.get(url_manifiesto, timeout=10)
            respuesta.raise_for_status()
            datos_manifiesto = respuesta.json()
            with open(ruta_cache, 'w') as f: json.dump(datos_manifiesto, f)
            return datos_manifiesto
        except (requests.RequestException, json.JSONDecodeError) as e:
            self.registrador.warning(f"Fallo al obtener manifiesto desde {url_manifiesto}: {e}")
            if ruta_cache.exists():
                self.registrador.info(f"Usando manifiesto en caché para {url_repo}")
                with open(ruta_cache, 'r') as f: return json.load(f)
            return None

    def buscar(self, termino_busqueda):
        self.registrador.info(f"Buscando '{termino_busqueda}'...")
        paquetes_encontrados = []
        for url_repo in self._obtener_urls_repos():
            manifiesto = self._obtener_manifiesto(url_repo)
            if not manifiesto or 'packages' not in manifiesto: continue
            for nombre_paquete, detalles_paquete in manifiesto['packages'].items():
                if termino_busqueda.lower() in nombre_paquete.lower():
                    detalles_paquete['name'] = nombre_paquete; detalles_paquete['repository_url'] = url_repo
                    paquetes_encontrados.append(detalles_paquete)
        if not paquetes_encontrados: self.registrador.info("No se encontraron paquetes que coincidan.")
        return paquetes_encontrados
    
    def _cargar_bd(self):
        if not self.config.BD_PAQUETES_INSTALADOS.exists(): return {}
        try:
            with open(self.config.BD_PAQUETES_INSTALADOS, 'r') as f: return json.load(f)
        except (json.JSONDecodeError, IOError): return {}

    def _guardar_bd(self, bd):
        with open(self.config.BD_PAQUETES_INSTALADOS, 'w') as f: json.dump(bd, f, indent=4)

    def _descargar_archivo(self, url, destino):
        try:
            self.registrador.info(f"Descargando desde {url} a {destino}")
            with self._sesion.get(url, stream=True, timeout=30) as r:
                r.raise_for_status()
                tamano_total = int(r.headers.get('content-length', 0))
                bytes_descargados = 0
                with open(destino, 'wb') as f:
                    for chunk in r.iter_content(chunk_size=8192):
                        f.write(chunk); bytes_descargados += len(chunk)
                        if tamano_total > 0 and self.callback_progreso:
                            self.callback_progreso(bytes_descargados / tamano_total)
            if self.callback_progreso: self.callback_progreso(1.0)
            return True
        except requests.RequestException as e:
            self.registrador.error(f"Fallo al descargar {url}: {e}"); return False

    def _verificar_checksum(self, ruta_archivo, sha256_esperado):
        sha256 = hashlib.sha256()
        with open(ruta_archivo, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""): sha256.update(chunk)
        return sha256.hexdigest() == sha256_esperado

    def instalar(self, nombre_paquete):
        self.registrador.info(f"Iniciando instalación para '{nombre_paquete}'...")
        resultados = self.buscar(nombre_paquete)
        if not resultados: raise ErrorTPT(f"Paquete '{nombre_paquete}' no encontrado.")
        info_paquete = resultados[0]
        dir_temp = self.config.DIR_CACHE / "descargas"; dir_temp.mkdir(exist_ok=True)
        nombre_archivo = info_paquete['download_url'].split('/')[-1]
        ruta_archivo_temp = dir_temp / nombre_archivo
        if not self._descargar_archivo(info_paquete['download_url'], ruta_archivo_temp):
            raise ErrorTPT("Fallo al descargar el paquete.")
        if 'sha256' in info_paquete and not self._verificar_checksum(ruta_archivo_temp, info_paquete['sha256']):
            raise ErrorTPT("Suma de verificación no coincide. El archivo puede estar corrupto.")
        
        extension = ''.join(Path(nombre_archivo).suffixes) if not info_paquete.get('extension') else info_paquete['extension']
        clase_instalador = obtener_clase_instalador(extension)
        if not clase_instalador: raise ErrorTPT(f"Tipo de paquete no soportado: {extension}")
        
        instalador = clase_instalador(info_paquete, ruta_archivo_temp, self.config, self.registrador)
        detalles = instalador.instalar()
        
        bd = self._cargar_bd()
        detalles['version'] = info_paquete.get('version', '0.0.0')
        bd[nombre_paquete] = detalles
        self._guardar_bd(bd)
        self.registrador.info(f"'{nombre_paquete}' (versión {detalles['version']}) instalado correctamente.")
        ruta_archivo_temp.unlink(missing_ok=True)

    def desinstalar(self, nombre_paquete):
        self.registrador.info(f"Desinstalando '{nombre_paquete}'...")
        bd = self._cargar_bd()
        if nombre_paquete not in bd: raise ErrorTPT(f"Paquete '{nombre_paquete}' no está instalado.")
        detalles = bd[nombre_paquete]
        clase_instalador = obtener_clase_instalador(detalles['extension'])
        if not clase_instalador: raise ErrorTPT(f"No se puede desinstalar: tipo de paquete no soportado '{detalles['extension']}'")
        instalador = clase_instalador(detalles, None, self.config, self.registrador)
        instalador.desinstalar(detalles)
        del bd[nombre_paquete]
        self._guardar_bd(bd)
        self.registrador.info(f"'{nombre_paquete}' desinstalado correctamente.")

    def listar_instalados(self):
        self.registrador.info("Listando paquetes instalados:")
        bd = self._cargar_bd()
        if not bd: print("No hay paquetes instalados por TPT."); return
        for nombre, detalles in bd.items():
            print(f"- {nombre} (v{detalles.get('version', 'N/A')}, Tipo: {detalles.get('extension', 'N/A')})")

    def reparar(self):
        self.registrador.info("Intentando reparar dependencias rotas del sistema...")
        InstaladorBase(None, None, self.config, self.registrador)._ejecutar_comando(["apt-get", "install", "-f", "-y"], como_root=True)
        self.registrador.info("Proceso de reparación de dependencias completado.")

# =============================================================================
# SECCIÓN 3: GESTORES DE INSTALACIÓN
# =============================================================================

class InstaladorBase:
    def __init__(self, info_paquete, ruta_archivo, config, registrador):
        self.info_paquete = info_paquete; self.ruta_archivo = ruta_archivo
        self.config = config; self.registrador = registrador
        self.nombre_app = info_paquete.get('name') if info_paquete else None

    def _ejecutar_comando(self, comando, como_root=False, **kwargs):
        if como_root and os.geteuid() != 0: comando.insert(0, "sudo")
        self.registrador.debug(f"Ejecutando: {' '.join(comando)}")
        try:
            resultado = subprocess.run(comando, check=True, text=True, capture_output=True, encoding='utf-8', **kwargs)
            if resultado.stdout: self.registrador.debug(resultado.stdout)
            if resultado.stderr: self.registrador.warning(resultado.stderr)
            return resultado
        except subprocess.CalledProcessError as e: raise ErrorTPT(f"Comando falló: {' '.join(comando)}\nError: {e.stderr}")

    def _crear_archivo_desktop(self, ruta_ejecutable):
        metadata = self.info_paquete.get("metadata", {})
        ruta_desktop = self.config.DIR_APLICACIONES_ROOT / f"{self.nombre_app}.desktop"
        contenido = f"""[Desktop Entry]\nVersion=1.0\nType=Application\nName={self.nombre_app}\nComment={self.info_paquete.get('description', '')}\nExec={ruta_ejecutable}\nIcon={metadata.get('icon', 'application-x-executable')}\nTerminal={'true' if str(metadata.get('terminal', 'false')).lower() == 'true' else 'false'}\nCategories={metadata.get('categories', 'Utility;')}"""
        try:
            self.registrador.info(f"Creando archivo .desktop en {ruta_desktop}")
            with open(ruta_desktop, "w", encoding='utf-8') as f: f.write(contenido)
            self._ejecutar_comando(["chmod", "644", str(ruta_desktop)], como_root=True)
            return str(ruta_desktop)
        except Exception as e: self.registrador.error(f"No se pudo crear el archivo .desktop: {e}"); return None

    def instalar(self): raise NotImplementedError
    def desinstalar(self, detalles): raise NotImplementedError

class InstaladorDeb(InstaladorBase):
    def instalar(self):
        self._ejecutar_comando(["dpkg", "-i", str(self.ruta_archivo)], como_root=True)
        return {"extension": ".deb", "instalador": "InstaladorDeb"}
    def desinstalar(self, detalles): self._ejecutar_comando(["dpkg", "-r", detalles['name']], como_root=True)

class InstaladorScript(InstaladorBase):
    def instalar(self):
        ruta_destino = self.config.DIR_EJECUTABLES_ROOT / self.nombre_app
        self._ejecutar_comando(["mv", str(self.ruta_archivo), str(ruta_destino)], como_root=True)
        self._ejecutar_comando(["chmod", "+x", str(ruta_destino)], como_root=True)
        ruta_desktop = self._crear_archivo_desktop(ruta_destino)
        return {"extension": self.info_paquete['extension'], "ruta_instalacion": str(ruta_destino), "desktop": ruta_desktop, "instalador": "InstaladorScript"}
    def desinstalar(self, detalles):
        if Path(detalles.get('ruta_instalacion', '')).exists(): self._ejecutar_comando(["rm", detalles['ruta_instalacion']], como_root=True)
        if Path(detalles.get('desktop', '')).exists(): self._ejecutar_comando(["rm", detalles['desktop']], como_root=True)

class InstaladorAppImage(InstaladorBase):
    def instalar(self):
        dir_destino = self.config.DIR_OPT_ROOT / "AppImages"; self._ejecutar_comando(["mkdir", "-p", str(dir_destino)], como_root=True)
        ruta_final = dir_destino / f"{self.nombre_app}.AppImage"
        enlace = self.config.DIR_EJECUTABLES_ROOT / self.nombre_app
        self._ejecutar_comando(["mv", str(self.ruta_archivo), str(ruta_final)], como_root=True)
        self._ejecutar_comando(["chmod", "+x", str(ruta_final)], como_root=True)
        if enlace.exists(): self._ejecutar_comando(["rm", str(enlace)], como_root=True)
        self._ejecutar_comando(["ln", "-s", str(ruta_final), str(enlace)], como_root=True)
        ruta_desktop = self._crear_archivo_desktop(enlace)
        return {"extension": ".AppImage", "ruta_instalacion": str(ruta_final), "enlace": str(enlace), "desktop": ruta_desktop, "instalador": "InstaladorAppImage"}
    def desinstalar(self, detalles):
        if Path(detalles.get('ruta_instalacion', '')).exists(): self._ejecutar_comando(["rm", detalles['ruta_instalacion']], como_root=True)
        if Path(detalles.get('enlace', '')).exists(): self._ejecutar_comando(["rm", detalles['enlace']], como_root=True)
        if Path(detalles.get('desktop', '')).exists(): self._ejecutar_comando(["rm", detalles['desktop']], como_root=True)

class InstaladorTarGz(InstaladorBase):
    def instalar(self):
        dir_extraccion = self.config.DIR_OPT_ROOT / self.nombre_app
        self._ejecutar_comando(["rm", "-rf", str(dir_extraccion)], como_root=True)
        self._ejecutar_comando(["mkdir", "-p", str(dir_extraccion)], como_root=True)
        self._ejecutar_comando(["tar", "-xzf", str(self.ruta_archivo), "-C", str(dir_extraccion), "--strip-components=1"], como_root=True)
        ejecutable = next((p for p in dir_extraccion.rglob('*') if p.is_file() and os.access(p, os.X_OK)), dir_extraccion / self.nombre_app)
        ruta_desktop = self._crear_archivo_desktop(ejecutable) if ejecutable.exists() else None
        return {"extension": ".tar.gz", "ruta_instalacion": str(dir_extraccion), "desktop": ruta_desktop, "instalador": "InstaladorTarGz"}
    def desinstalar(self, detalles):
        if Path(detalles.get('ruta_instalacion', '')).exists(): self._ejecutar_comando(["rm", "-rf", detalles['ruta_instalacion']], como_root=True)
        if Path(detalles.get('desktop', '')).exists(): self._ejecutar_comando(["rm", detalles['desktop']], como_root=True)

def obtener_clase_instalador(extension):
    return {
        ".deb": InstaladorDeb, ".sh": InstaladorScript, ".py": InstaladorScript,
        ".AppImage": InstaladorAppImage, ".tar.gz": InstaladorTarGz, ".nemas_pkg": InstaladorTarGz,
    }.get(extension)

# =============================================================================
# SECCIÓN 4: INTERFACES DE USUARIO
# =============================================================================

class InterfazCLI:
    def __init__(self, gestor_paquetes):
        self.gestor = gestor_paquetes

    def ejecutar(self):
        parser = argparse.ArgumentParser(prog="tpt", description="TPT - La Herramienta de Paquetes de Tovicito.")
        subparsers = parser.add_subparsers(dest="comando", help="Comandos disponibles")
        try: subparsers.required = True
        except AttributeError: pass
        p_buscar = subparsers.add_parser("buscar", help="Buscar un paquete.")
        p_buscar.add_argument("termino_busqueda", help="El nombre del paquete a buscar.")
        p_instalar = subparsers.add_parser("instalar", help="Instalar un paquete.")
        p_instalar.add_argument("nombre_paquete", help="El nombre del paquete a instalar.")
        p_desinstalar = subparsers.add_parser("desinstalar", help="Desinstalar un paquete.")
        p_desinstalar.add_argument("nombre_paquete", help="El nombre del paquete a desinstalar.")
        subparsers.add_parser("listar", help="Listar todos los paquetes instalados.")
        p_actualizar = subparsers.add_parser("actualizar", help="Actualizar paquetes.")
        p_actualizar.add_argument("nombre_paquete", nargs='?', default=None, help="Paquete específico a actualizar, o todos si se omite.")
        subparsers.add_parser("reparar", help="Intentar reparar dependencias rotas del sistema.")
        subparsers.add_parser("gui", help="Lanzar la interfaz gráfica de usuario.")
        args = parser.parse_args()

        if args.comando == "buscar": self.gestor.buscar(args.termino_busqueda)
        elif args.comando == "instalar": self.gestor.instalar(args.nombre_paquete)
        elif args.comando == "desinstalar": self.gestor.desinstalar(args.nombre_paquete)
        elif args.comando == "listar": self.gestor.listar_instalados()
        elif args.comando == "reparar": self.gestor.reparar()
        elif args.comando == "gui":
            if not HAS_GTK: raise ErrorCriticoTPT("El modo GUI requiere PyGObject.")
            InterfazGUI(self.gestor).run()

# =============================================================================
# SECCIÓN 5: EJECUCIÓN PRINCIPAL
# =============================================================================

def main():
    """Función principal para inicializar y ejecutar la aplicación."""
    configuracion = Configuracion()
    configuracion.asegurar_directorios()
    registrador = RegistradorTPT(configuracion)
    gestor = GestorPaquetes(configuracion, registrador)

    try:
        if len(sys.argv) == 1 or (len(sys.argv) > 1 and sys.argv[1] == 'gui'):
            if not HAS_GTK: raise ErrorCriticoTPT("El modo GUI requiere PyGObject, pero no está instalado.")
            if not os.environ.get("DISPLAY"): raise ErrorCriticoTPT("El modo GUI requiere una pantalla, pero no hay ninguna disponible.")
            registrador.info("Lanzando GUI.")
            app_gui = InterfazGUI(gestor)
            sys.exit(app_gui.run())
        else:
            app_cli = InterfazCLI(gestor)
            app_cli.ejecutar()
    except ErrorCriticoTPT as e:
        registrador.critical(str(e)); sys.exit(1)
    except ErrorTPT as e:
        registrador.error(str(e)); sys.exit(1)
    except KeyboardInterrupt:
        registrador.info("\nOperación cancelada por el usuario."); sys.exit(130)
    except Exception as e:
        registrador.critical(f"Ocurrió un error inesperado: {e}", exc_info=True); sys.exit(1)

if __name__ == "__main__":
    main()
